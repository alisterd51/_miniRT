/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   albedo.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anclarma <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/07/10 14:05:03 by anclarma          #+#    #+#             */
/*   Updated: 2020/07/21 15:20:26 by anclarma         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "struct.h"
#include "vector.h"

t_vector	sphere_albedo(t_obj s, int sphere_id)
{
	t_sphere	*s_ptr;

	s_ptr = s.lst_sphere;
	while (s_ptr)
	{
		if (s_ptr->id == sphere_id)
			return (int_to_vector(s_ptr->color));
		s_ptr = s_ptr->next;
	}
	return (init_vector(0.0, 0.0, 0.0));
}

t_vector	triangle_albedo(t_obj s, int triangle_id)
{
	t_triangle	*tr_ptr;

	tr_ptr = s.lst_triangle;
	while (tr_ptr)
	{
		if (tr_ptr->id == triangle_id)
			return (int_to_vector(tr_ptr->color));
		tr_ptr = tr_ptr->next;
	}
	return (init_vector(0.0, 0.0, 0.0));
}

t_vector	plane_albedo(t_obj s, int plane_id)
{
	t_plane		*pl_ptr;

	pl_ptr = s.lst_plane;
	while (pl_ptr)
	{
		if (pl_ptr->id == plane_id)
			return (int_to_vector(pl_ptr->color));
		pl_ptr = pl_ptr->next;
	}
	return (init_vector(0.0, 0.0, 0.0));
}

t_vector	cylinder_albedo(t_obj s, int cylinder_id)
{
	t_cylinder	*cy_ptr;

	cy_ptr = s.lst_cylinder;
	while (cy_ptr)
	{
		if (cy_ptr->id == cylinder_id)
			return (int_to_vector(cy_ptr->color));
		cy_ptr = cy_ptr->next;
	}
	return (init_vector(0.0, 0.0, 0.0));
}

t_vector	square_albedo(t_obj s, int square_id)
{
	t_square	*sq_ptr;

    sq_ptr = s.lst_square;
    while (sq_ptr)
    {
        if (sq_ptr->id == square_id)
            return (int_to_vector(sq_ptr->color));
        sq_ptr = sq_ptr->next;
    }
    return (init_vector(0.0, 0.0, 0.0));
}

t_vector	obj_albedo(t_obj s, int obj_id[2])
{
	if (obj_id[0] == 1)
		return (sphere_albedo(s, obj_id[1]));
	else if (obj_id[0] == 2)
		return (plane_albedo(s, obj_id[1]));
	else if (obj_id[0] == 3)
        return (square_albedo(s, obj_id[1]));
	else if (obj_id[0] == 4)
		return (cylinder_albedo(s, obj_id[1]));
	else if (obj_id[0] == 5)
		return (triangle_albedo(s, obj_id[1]));
	return (init_vector(0, 0, 0));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   extremum.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anclarma <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/07/09 19:26:19 by anclarma          #+#    #+#             */
/*   Updated: 2020/07/09 19:27:15 by anclarma         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

double	max(double a, double b)
{
	if (a > b)
		return (a);
	return (b);
}

double	min(double a, double b)
{
	if (a < b)
		return (a);
	return (b);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   getcolor.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anclarma <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/07/10 09:57:05 by anclarma          #+#    #+#             */
/*   Updated: 2020/07/16 12:34:41 by anclarma         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "struct.h"
#include "vector.h"
#include "extremum.h"
#include "this_obj_is.h"
#include "albedo.h"
#include "intersect.h"
#include <math.h>

t_vector	getcolor(const t_ray *r, const t_obj *s, int nbrebonds)
{
	if (nbrebonds == 0)
		return (init_vector(0.0, 0.0, 0.0));

	t_vector	p, n;
	//	int			sphere_id = 0;
	int			obj_id[2] = {0, 0};
	//	int			type_obj = 0;
	//	int			obj_id = 0;
	double		t;

	//
	t_check_scene	check;

	check.scene = *s;
	check.ray = *r;
	(check.obj_id)[0] = 0;
	(check.obj_id)[1] = 0;
	//
	(void)t;
	//

	int			has_inter = rt_inter_scene(&check);
	//
	p = check.p;
	n = check.n;
	obj_id[0] = (check.obj_id)[0];
	obj_id[1] = (check.obj_id)[1];
	t = check.t;
	//
	t_vector	intensite_pixel = init_vector(0.0, 0.0, 0.0);

	if (has_inter)
	{
		if (this_obj_is_mirror(*s, obj_id))
		{
			t_ray	ray_mirror;

			ray_mirror.d = sub_vector(r->d, mult_vector(2.0 * dot(n, r->d), n));
			ray_mirror.o = add_vector(p, mult_vector(0.001, n));
			intensite_pixel = getcolor(&ray_mirror, s, nbrebonds - 1);
		}
		else if (this_obj_is_transp(*s, obj_id))
		{
			t_ray   ray_refract;
			t_vector	N_transp = n;
			double	n1 = 1.0;
			double	n2 = 1.3;

			if (dot(r->d, n) > 0.0)
			{
				n1 = 1.3;
				n2 = 1.0;
				N_transp = mult_vector(-1.0, n);
			}

			double	radical = 1.0 - sqrt(n1/n2) * (1 - sqrt(dot(N_transp, r->d)));
			if (radical > 0.0)
			{
				ray_refract.d = sub_vector(mult_vector((n1 / n2), sub_vector(r->d, mult_vector(dot(r->d, N_transp), N_transp))), mult_vector(sqrt(radical), N_transp));
				ray_refract.o = sub_vector(p, mult_vector(0.001, N_transp));
				intensite_pixel = getcolor(&ray_refract, s, nbrebonds - 1);
			}
		}
		else
		{
			t_ray		ray_light;
			ray_light.d = normalize(sub_vector(s->lst_light->c, p));
			ray_light.o = add_vector(p, mult_vector(0.001, n));
			t_vector	P_light, N_light;
			int			obj_id_light[2] = {0, 0};
			double		t_light;
			//
			t_check_scene   check_light;

			check_light.scene = *s;
			check_light.ray = ray_light;
			(check_light.obj_id)[0] = 0;
			(check_light.obj_id)[1] = 0;
			//
			int			has_inter_light = rt_inter_scene(&check_light);
			//
			P_light = check.p;
			N_light = check.n;
			obj_id_light[0] = (check_light.obj_id)[0];
			obj_id_light[1] = (check_light.obj_id)[1];
			t_light = check_light.t;
			//
			(void)obj_id_light;
			(void)P_light;
			(void)N_light;
			//
			double		d_light2 = norm2(sub_vector(s->lst_light->c, p));

			if (has_inter_light && t_light * t_light < d_light2)
			{
				intensite_pixel = init_vector(0.0, 0.0, 0.0);
				//a placer dans une fonction d'éclairage ambiant
				//intensite_pixel = mult_vector(s->amblight->ratio * 20, div_vector(obj_albedo(*s, obj_id), M_PI));
			}
			else
			{
				intensite_pixel = div_vector(mult_vector(s->intensite_lumiere * max(0.0, dot(normalize(sub_vector(s->lst_light->c, p)) , n)), div_vector(obj_albedo(*s, obj_id), M_PI)) , d_light2);
			}
			/*en attente générateur nb aléatoire.
			  t_ray   ray_alea;
			  double		r1 = ;//nb entre 0 et 1, distribution normal aléatoire.
			  t_vector	dir_alea_repere_local = ;

			  ray_alea.d = ;
			  ray_alea.o = add_vector(P, mult_vector(0.001, N));
			  intensite_pixel = add_vector(intensite_pixel, getcolor(&ray_alea, s, nbrebonds - 1));*/
		}
	}
	return (intensite_pixel);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_obj1.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anclarma <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/07/13 10:38:48 by anclarma          #+#    #+#             */
/*   Updated: 2020/07/16 14:47:12 by anclarma         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "struct.h"
#include "libft.h"

int			read_int(char **line)
{
	int			ret;

	while (ft_isspace(**line))
		(*line)++;
	ret = ft_atoi(*line);
	if (**line == '+' || **line == '-')
		(*line)++;
	while (ft_isdigit(**line))
		(*line)++;
	if (**line == ',')
		(*line)++;
	return (ret);
}

double		read_float(char **line)
{
	double		ret;

	while (ft_isspace(**line))
		(*line)++;
	ret = ft_atof(*line);
	if (**line == '+' || **line == '-')
		(*line)++;
	while (ft_isdigit(**line))
		(*line)++;
	if (**line == '.')
		(*line)++;
	while (ft_isdigit(**line))
		(*line)++;
	if (**line == ',')
		(*line)++;
	return (ret);
}

t_vector	read_vec(char **line)
{
	t_vector	vec;

	vec.x = read_float(line);
	vec.y = read_float(line);
	vec.z = read_float(line);
	return (vec);
}

int			read_color(char **line)
{
	int			ret;

	ret = read_int(line) * 0x00010000;
	ret += read_int(line) * 0x00000100;
	ret += read_int(line);
	return (ret);
}

int			read_option(char **line)
{
	int			ret;

	while (ft_isspace(**line))
		(*line)++;
	if (**line == 'm')
		ret = 1;
	else
		ret = 0;
	return (ret);
}

int			read_option2(char **line)
{
	int			ret;

	while (ft_isspace(**line))
		(*line)++;
	if (**line == 't')
		ret = 1;
	else
		ret = 0;
	return (ret);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_obj2.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anclarma <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/07/13 10:39:48 by anclarma          #+#    #+#             */
/*   Updated: 2020/07/13 17:30:32 by anclarma         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "struct.h"
#include "init_obj.h"
#include "libft.h"
#include <stdlib.h>

void	init_obj(t_obj *obj)
{
	obj->resolution = NULL;
	obj->amblight = NULL;
	obj->lst_cam = NULL;
	obj->lst_light = NULL;
	obj->lst_sphere = NULL;
	obj->lst_plane = NULL;
	obj->lst_square = NULL;
	obj->lst_cylinder = NULL;
	obj->lst_triangle = NULL;
}

int		init_res(char *line, t_obj *obj)
{
	if (!(obj->resolution = malloc(sizeof(t_res))))
		return (1);
	obj->resolution->x_size = read_int(&line);
	obj->resolution->y_size = read_int(&line);
	return (0);
}

int		init_amblight(char *line, t_obj *obj)
{
	if (!(obj->amblight = malloc(sizeof(t_amblight))))
		return (1);
	obj->amblight->ratio = read_float(&line);
	obj->amblight->color = read_color(&line);
	return (0);
}

int		init_cam(char *line, t_obj *obj)
{
	t_camera	*new_cam;
	t_camera	*ptr_tmp;

	if (!(new_cam = malloc(sizeof(t_camera))))
		return (1);
	new_cam->id = 0;	// remplir avec le num de la cam [0, 1, ...]
	new_cam->c = read_vec(&line);
	new_cam->vec = read_vec(&line);
	new_cam->fov = read_int(&line);
	new_cam->next = NULL;
	if (obj->lst_cam == NULL)
		obj->lst_cam = new_cam;
	else
	{
		ptr_tmp = obj->lst_cam;
		while (ptr_tmp->next != NULL)
			ptr_tmp = ptr_tmp->next;
		ptr_tmp->next = new_cam;
	}
	return (0);
}

int		init_light(char *line, t_obj *obj)
{
	t_light		*new_light;
	t_light		*ptr_tmp;

	if (!(new_light = malloc(sizeof(t_light))))
		return (1);
	new_light->id = 0;	// remplir avec le num de la cam [0, 1, ...]
	new_light->c = read_vec(&line);
	new_light->ratio = read_float(&line);
	new_light->color = read_color(&line);
	new_light->next = NULL;

	if (obj->lst_light == NULL)
		obj->lst_light = new_light;
	else
	{
		ptr_tmp = obj->lst_light;
		while (ptr_tmp->next != NULL)
			ptr_tmp = ptr_tmp->next;
		ptr_tmp->next = new_light;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_obj3.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anclarma <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/07/13 10:40:45 by anclarma          #+#    #+#             */
/*   Updated: 2020/07/16 12:23:59 by anclarma         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "struct.h"
#include "init_obj.h"
#include "libft.h"
#include <stdlib.h>

int	init_sphere(char *line, t_obj *obj)
{
	t_sphere		*new_sphere;
	t_sphere		*ptr_tmp;
	int				num_sphere;

	if (!(new_sphere = malloc(sizeof(t_sphere))))
		return (1);
	new_sphere->id = 0;
	new_sphere->c = read_vec(&line);
	new_sphere->radius = read_float(&line);
	new_sphere->color = read_color(&line);
	new_sphere->mirror = read_option(&line);
	new_sphere->transp = read_option2(&line);
	new_sphere->next = NULL;
	num_sphere = 0;
	if (obj->lst_sphere == NULL)
		obj->lst_sphere = new_sphere;
	else
	{
		num_sphere++;
		ptr_tmp = obj->lst_sphere;
		while (ptr_tmp->next != NULL)
		{
			num_sphere++;
			ptr_tmp = ptr_tmp->next;
		}
		new_sphere->id = num_sphere;
		ptr_tmp->next = new_sphere;
	}
	return (0);
}

int	init_plane(char *line, t_obj *obj)
{
	t_plane		*new_plane;
	t_plane		*ptr_tmp;

	if (!(new_plane = malloc(sizeof(t_plane))))
		return (1);
	new_plane->id = 0;
	new_plane->c = read_vec(&line);
	new_plane->o = read_vec(&line);
	new_plane->color = read_color(&line);
	new_plane->next = NULL;
	if (obj->lst_plane == NULL)
		obj->lst_plane = new_plane;
	else
	{
		new_plane->id++;
		ptr_tmp = obj->lst_plane;
		while (ptr_tmp->next != NULL)
		{
			new_plane->id++;
			ptr_tmp = ptr_tmp->next;
		}
		ptr_tmp->next = new_plane;
	}
	return (0);
}

int	init_square(char *line, t_obj *obj)
{
	t_square	*new_square;
	t_square	*ptr_tmp;

	if (!(new_square = malloc(sizeof(t_square))))
		return (1);
	new_square->id = 0;
	new_square->c = read_vec(&line);
	new_square->o = read_vec(&line);
	new_square->height = read_float(&line);
	new_square->color = read_color(&line);
	new_square->next = NULL;
	if (obj->lst_square == NULL)
		obj->lst_square = new_square;
	else
	{
		new_square->id++;
		ptr_tmp = obj->lst_square;
		while (ptr_tmp->next != NULL)
		{
			new_square->id++;
			ptr_tmp = ptr_tmp->next;
		}
		ptr_tmp->next = new_square;
	}
	return (0);
}

int	init_cylinder(char *line, t_obj *obj)
{
	t_cylinder	*new_cylinder;
	t_cylinder	*ptr_tmp;

	if (!(new_cylinder = malloc(sizeof(t_cylinder))))
		return (1);
	new_cylinder->id = 0;
	new_cylinder->c = read_vec(&line);
	new_cylinder->o = read_vec(&line);
	new_cylinder->radius = read_float(&line);
	new_cylinder->height = read_float(&line);
	new_cylinder->color = read_color(&line);
	new_cylinder->next = NULL;
	if (obj->lst_cylinder == NULL)
		obj->lst_cylinder = new_cylinder;
	else
	{
		new_cylinder->id++;
		ptr_tmp = obj->lst_cylinder;
		while (ptr_tmp->next != NULL)
		{
			new_cylinder->id++;
			ptr_tmp = ptr_tmp->next;
		}
		ptr_tmp->next = new_cylinder;
	}
	return (0);
}

int	init_triangle(char *line, t_obj *obj)
{
	t_triangle	*new_triangle;
	t_triangle	*ptr_tmp;

	if (!(new_triangle = malloc(sizeof(t_triangle))))
		return (1);
	new_triangle->id = 0;
	new_triangle->p1 = read_vec(&line);
	new_triangle->p2 = read_vec(&line);
	new_triangle->p3 = read_vec(&line);
	new_triangle->color = read_color(&line);
	new_triangle->next = NULL;
	if (obj->lst_triangle == NULL)
		obj->lst_triangle = new_triangle;
	else
	{
		new_triangle->id++;
		ptr_tmp = obj->lst_triangle;
		while (ptr_tmp->next != NULL)
		{
			new_triangle->id++;
			ptr_tmp = ptr_tmp->next;
		}
		ptr_tmp->next = new_triangle;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   initpixel.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anclarma <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/07/09 09:07:12 by anclarma          #+#    #+#             */
/*   Updated: 2020/07/09 11:34:50 by anclarma         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "struct.h"
#include <stdlib.h>

void	initpixel(t_mlx *mlx)
{
	int	i;

	mlx->pixel = malloc(sizeof(int *) * mlx->obj.resolution->y_size);
	i = -1;
	while (++i < mlx->obj.resolution->y_size)
		mlx->pixel[i] = malloc(sizeof(int) * mlx->obj.resolution->x_size);
	mlx->size_line = mlx->obj.resolution->x_size * 4;
	mlx->bpp = 32;
	mlx->endian = 1;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   input.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anclarma <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/07/09 09:45:20 by anclarma          #+#    #+#             */
/*   Updated: 2020/07/21 15:24:57 by anclarma         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "struct.h"
#include "render.h"
#include "input.h"
#include "vector.h"
#include <stdio.h>
#include <stdlib.h>
#include <mlx.h>
#include <math.h>

#include "libft.h"

int		deal_mouse(int button, int x, int y, void *param)
{
	t_mlx	*mlx;
	char	chaine[100];

	mlx = (t_mlx *)param;
	sprintf(chaine, "button%d, x:%d, y:%d\n", button, x, y);
	mlx_string_put(mlx->mlx_ptr, mlx->win_ptr, x, y, 0X00FFFFFF, chaine);
	return (0);
}

void	thisiskey1(int key, t_mlx *mlx)
{
	if (key == R_KEY)
		render(mlx);
	if (key == UP_KEY)
	{
		mlx->obj.lst_cam->c.z -= 2;
		prerender(mlx);
	}
	if (key == DOWN_KEY)
	{
		mlx->obj.lst_cam->c.z += 2;
		prerender(mlx);
	}
	if (key == S_KEY)
	{
		mlx->obj.lst_cam->c.y -= 2;
		prerender(mlx);
	}
	if (key == Z_KEY)
	{
		mlx->obj.lst_cam->c.y += 2;
		prerender(mlx);
	}
}

void	thisiskey2(int key, t_mlx *mlx)
{
	if (key == LEFT_KEY)
	{
		mlx->obj.lst_cam->c.x -= 2;
		prerender(mlx);
	}
	if (key == RIGHT_KEY)
	{
		mlx->obj.lst_cam->c.x += 2;
		prerender(mlx);
	}
	if (key == Q_KEY)
	{
		mlx->obj.lst_cam->vec = rot_right(mlx->obj.lst_cam->vec, M_PI / 4);
		//mlx->obj.lst_cam->vec.x -= 2;
		prerender(mlx);
	}
	if (key == D_KEY)
	{
		mlx->obj.lst_cam->vec = rot_left(mlx->obj.lst_cam->vec, M_PI / 4);
		//mlx->obj.lst_cam->vec.x += 2;
		prerender(mlx);
	}
	if (key == ESC_KEY)
		exit(0);
}

int		deal_key(int key, void *param)
{
	t_mlx	*mlx;

	ft_printf("entree deal_key num: %d\n", key);
	mlx = (t_mlx *)param;
	thisiskey1(key, mlx);
	thisiskey2(key, mlx);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   intersect1.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anclarma <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/07/10 14:13:08 by anclarma          #+#    #+#             */
/*   Updated: 2020/07/17 15:02:22 by anclarma         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "struct.h"
#include "intersect.h"

int		rt_inter_scene(t_check_scene *check)
{
	int		has_inter;

	has_inter = 0;
	check->min_t = 1e99;
	(check->obj_id)[0] = 0;
	(check->obj_id)[1] = 0;
	while (check->scene.lst_sphere)
	{
		has_inter += check_inter_sphere(check);
		check->scene.lst_sphere = check->scene.lst_sphere->next;
	}
	while (check->scene.lst_plane)
	{
		has_inter += check_inter_plane(check);
		check->scene.lst_plane = check->scene.lst_plane->next;
	}
	while (check->scene.lst_triangle)
	{
		has_inter += check_inter_triangle(check);
		check->scene.lst_triangle = check->scene.lst_triangle->next;
	}
	return (has_inter);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   intersect2.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anclarma <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/07/10 14:36:50 by anclarma          #+#    #+#             */
/*   Updated: 2020/07/16 12:30:55 by anclarma         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "struct.h"
#include "intersect.h"
#include "vector.h"
#include <math.h>

int	rt_inter_sphere(const t_ray ray, const t_sphere s, t_vector *p,
		t_vector *n, double *t)
{
	double	a;
	double	b;
	double	c;
	double	delta;
	double	t1;
	double	t2;

	a = 1;
	b = 2 * dot(ray.d, sub_vector(ray.o, s.c));
	c = norm2(sub_vector(ray.o, s.c)) - s.radius * s.radius;
	delta = b * b - 4.0 * a * c;
	if (delta < 0)
		return (0);
	t1 = ((-b - sqrt(delta)) / (2 * a));
	t2 = ((-b + sqrt(delta)) / (2 * a));
	if (t2 < 0.0)
		return (0);
	if (t1 > 0.0)
		*t = t1;
	else
		*t = t2;
	*p = add_vector(ray.o, mult_vector(*t, ray.d));
	*n = normalize(sub_vector(*p, s.c));
	return (1);
}

int	check_inter_sphere(t_check_scene *check)
{
	int			has_inter;
	t_local		local;

	local.has_inter = rt_inter_sphere(check->ray, *(check->scene.lst_sphere),
			&(local.p), &(local.n), &(local.t));
	has_inter = 0;
	if (local.has_inter)
	{
		if (local.t < check->min_t)
		{
			check->min_t = local.t;
			check->t = local.t;
			check->p = local.p;
			check->n = local.n;
			(check->obj_id)[0] = 1;
			(check->obj_id)[1] = check->scene.lst_sphere->id;
		}
		has_inter = 1;
	}
	return (has_inter);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   intersect3.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anclarma <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/07/13 19:16:21 by anclarma          #+#    #+#             */
/*   Updated: 2020/07/16 12:29:23 by anclarma         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "struct.h"
#include "vector.h"

int		rt_inter_plane(const t_ray ray, const t_plane pl, t_vector *p,
		t_vector *n, double *t)
{
	*n = pl.o;
	if (dot(ray.d, *n) == 0.0)
		return (0);
	*t = dot(sub_vector(pl.c, ray.o), pl.o) / dot(ray.d, *n);
	if (*t < 0.0)
		return (0);
	*p = add_vector(ray.o, mult_vector(*t, ray.d));
	return (1);
}

int		check_inter_plane(t_check_scene *check)
{
	int			has_inter;
	t_local		local;

	local.has_inter = rt_inter_plane(check->ray, *(check->scene.lst_plane),
			&(local.p), &(local.n), &(local.t));
	has_inter = 0;
	if (local.has_inter)
	{
		if (local.t < check->min_t)
		{
			check->min_t = local.t;
			check->t = local.t;
			check->p = local.p;
			check->n = local.n;
			(check->obj_id)[0] = 2;
			(check->obj_id)[1] = check->scene.lst_plane->id;
		}
		has_inter = 1;
	}
	return (has_inter);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   intersect4.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anclarma <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/07/17 15:49:20 by anclarma          #+#    #+#             */
/*   Updated: 2020/07/17 16:00:18 by anclarma         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "struct.h"
#include "vector.h"

int		rt_inter_triangle(const t_ray ray, const t_triangle tr, t_vector *P,
		t_vector *N, double *t)
{
	const double    epsilon = 0.0000001;

	t_vector	vertex0 = tr.p1;
	t_vector	vertex1 = tr.p2;
	t_vector	vertex2 = tr.p3;
	t_vector	edge1, edge2, h, s, q;
	double		a, f, u, v;
	edge1 = sub_vector(vertex1, vertex0);
	edge2 = sub_vector(vertex2, vertex0);
	h = prod_vector(ray.d, edge2);
	a = dot(edge1, h);
	if (a > -epsilon && a < epsilon)
		return (0);
	f = 1.0 / a;
	s = sub_vector(ray.o, vertex0);
	u = f * dot(s, h);
	if (u < 0.0 || u > 1.0)
		return (0);
	q = prod_vector(s, edge1);
	v = f * dot(ray.d, q);
	if (v < 0.0 || u + v > 1.0)
		return (0);
	*t = f * dot(edge2, q);
	if (*t > epsilon)
	{
		*P = add_vector(ray.o, mult_vector(*t, ray.d));
		*N = normalize(prod_vector(edge1, edge2));
		return (1);
	}
	return (0);
}

int		check_inter_triangle(t_check_scene *check)
{
	int			has_inter;
	t_local		local;

	local.has_inter = rt_inter_triangle(check->ray, *(check->scene.lst_triangle),
			&(local.p), &(local.n), &(local.t));
	has_inter = 0;
	if (local.has_inter)
	{
		if (local.t < check->min_t)
		{
			check->min_t = local.t;
			check->t = local.t;
			check->p = local.p;
			check->n = local.n;
			(check->obj_id)[0] = 5;
			(check->obj_id)[1] = check->scene.lst_triangle->id;
		}
		has_inter = 1;
	}
	return (has_inter);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   intersect5.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anclarma <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/07/21 10:43:02 by anclarma          #+#    #+#             */
/*   Updated: 2020/07/21 13:32:11 by anclarma         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "struct.h"

int rt_inter_square(const t_ray ray, const t_square sq, t_vector *p,
        t_vector *n, double *t)
{
	
}

int	check_inter_square(t_check_scene *check)
{
	int			has_inter;
	t_local		local;

	local.has_inter = rt_inter_square(check->ray, *(check->scene.lst_square),
			&(local.p), &(local.n), &(local.t));
	has_inter = 0;
	if (local.has_inter)
	{
		if (local.t < check->min_t)
		{
			check->min_t = local.t;
			check->t = local.t;
			check->p = local.p;
			check->n = local.n;
			(check->obj_id)[0] = 3;
			(check->obj_id)[1] = check->scene.lst_square->id;
		}
		has_inter = 1;
	}
	return (has_inter);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anclarma <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/07/09 00:24:50 by anclarma          #+#    #+#             */
/*   Updated: 2020/07/14 10:12:52 by anclarma         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <mlx.h>
#include <stdlib.h>
#include "libft.h"
#include "struct.h"
#include "parser.h"
#include "initpixel.h"
#include "input.h"
#define WINDOW_TITLE "Test"

int	main(int ac, char **av)
{
	t_mlx	mlx;

	if (ac == 2)
		parser(av[1], &(mlx.obj));
	else
	{
		ft_printf("veuillez indiquer un fichier .rt en argument\n");
		exit(0);
	}
	mlx.width = mlx.obj.resolution->x_size;
	mlx.height = mlx.obj.resolution->y_size;
	mlx.mlx_ptr = mlx_init();
	mlx.img_ptr = mlx_new_image(mlx.mlx_ptr, mlx.width, mlx.height);
	mlx.image = (int *)mlx_get_data_addr(mlx.img_ptr, &(mlx.bpp),
			&(mlx.size_line), &(mlx.endian));
	mlx.win_ptr = mlx_new_window(mlx.mlx_ptr, mlx.width,
			mlx.height, WINDOW_TITLE);
	initpixel(&mlx);
	mlx_key_hook(mlx.win_ptr, deal_key, (void *)&mlx);
	mlx_mouse_hook(mlx.win_ptr, deal_mouse, (void *)&mlx);
	mlx_loop(mlx.mlx_ptr);
	exit(0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anclarma <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/07/13 10:27:23 by anclarma          #+#    #+#             */
/*   Updated: 2020/07/16 12:20:17 by anclarma         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "struct.h"
#include "libft.h"
#include "init_obj.h"
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>

int		parser1(char *line, t_obj *obj)
{
	char	c1;
	char	c2;
	int		error;

	c1 = *line;
	c2 = c1 ? *(line + 1) : 0;
	if (c1 == 'R' && ft_isspace(c2))
		error = init_res(line + 1, obj);
	else if (c1 == 'A' && ft_isspace(c2))
		error = init_amblight(line + 1, obj);
	else if (c1 == 'c' && ft_isspace(c2))
		error = init_cam(line + 1, obj);
	else if (c1 == 'l' && ft_isspace(c2))
		error = init_light(line + 1, obj);
	else if (c1 == 's' && c2 == 'p')
		error = init_sphere(line + 2, obj);
	else if (c1 == 'p' && c2 == 'l')
		error = init_plane(line + 2, obj);
	else if (c1 == 's' && c2 == 'q')
		error = init_square(line + 2, obj);
	else if (c1 == 'c' && c2 == 'y')
		error = init_cylinder(line + 2, obj);
	else if (c1 == 't' && c2 == 'r')
		error = init_triangle(line + 2, obj);
	else
		error = 0;
	return (error);
}

void	parser(char *file, t_obj *obj)
{
	int		fd;
	int		ret;
	char	*line;

	init_obj(obj);
	fd = open(file, O_RDONLY);
	ret = 0;
	while ((ret = get_next_line(fd, &line)) == 1)
	{
		parser1(line, obj);
		free(line);
	}
	parser1(line, obj);
	free(line);
	close(fd);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   render.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anclarma <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/07/09 11:02:21 by anclarma          #+#    #+#             */
/*   Updated: 2020/07/20 14:57:46 by anclarma         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "struct.h"
#include "scenescan.h"
#include "vector.h"
#include <stdlib.h>
#include <mlx.h>

static int	moyenne(int param_aa, t_mlx *mlx, int x, int y)
{
	t_vector	somme;
	int			i;
	int			j;

	somme = init_vector(0.0, 0.0, 0.0);
	x *= param_aa;
	y *= param_aa;
	i = 0;
	while (i < param_aa)
	{
		j = 0;
		while (j < param_aa)
		{
			somme = add_vector(somme, int_to_vector(mlx->image[(mlx->height
							- x - i - 1) * mlx->width + y + j]));
			j++;
		}
		i++;
	}
	return (vector_to_ints(div_vector(somme, (param_aa * param_aa))));
}

void		oversampling(t_mlx *mlx)
{
	const int	height_native = mlx->height;
	const int	width_native = mlx->width;
	int			*image_final = mlx->image;
	int			param_aa = 4;
	int			x;
	int			y;

	mlx->height *= param_aa;
	mlx->width *= param_aa;
	mlx->image = malloc(mlx->height * mlx->width * sizeof(int));
	scenescan(mlx);
	x = 0;
	while (x < height_native)
	{
		y = 0;
		while(y < width_native)
		{
			image_final[(height_native - x - 1) * width_native + y] =
				moyenne(param_aa, mlx, x, y);
			y++;
		}
		x++;
	}
	free(mlx->image);
	mlx->image = image_final;
	mlx->height = height_native;
	mlx->width = width_native;
}

void		prerendered(t_mlx *mlx)
{
	const int	height_native = mlx->height;
	const int	width_native = mlx->width;
	int			*image_final = mlx->image;
	int			param = 16;
	int			x;
	int			y;

	mlx->height /= param;
	mlx->width /= param;
	mlx->image = malloc(mlx->height * mlx->width * sizeof(int));
	scenescan(mlx);
	x = 0;
	while (x < height_native)
	{
		y = 0;
		while(y < width_native)
		{
			image_final[(height_native - x - 1) * width_native + y] =
				mlx->image[(mlx->height - x / param - 1) * mlx->width + y / param];
			y++;
		}
		x++;
	}
	free(mlx->image);
	mlx->image = image_final;
	mlx->height = height_native;
	mlx->width = width_native;
}

void	render(t_mlx *mlx)
{
	t_vector	sauv_vec;
	sauv_vec = mlx->obj.lst_cam->vec;
	mlx->obj.lst_cam->vec = mult_vector(16.0, mlx->obj.lst_cam->vec);
	oversampling(mlx);
	mlx->obj.lst_cam->vec = sauv_vec;
	mlx_put_image_to_window(mlx->mlx_ptr, mlx->win_ptr, mlx->img_ptr, 0, 0);
}

void	prerender(t_mlx *mlx)
{
	prerendered(mlx);
	mlx_put_image_to_window(mlx->mlx_ptr, mlx->win_ptr, mlx->img_ptr, 0, 0);
	mlx_string_put(mlx->mlx_ptr, mlx->win_ptr, 10, 10, 0X00FFFFFF, "pre-render");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   scenescan.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anclarma <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/07/09 21:58:35 by anclarma          #+#    #+#             */
/*   Updated: 2020/07/20 13:45:33 by anclarma         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "struct.h"
#include "vector.h"
#include "getcolor.h"
#include <pthread.h>
#include <math.h>
#define NB_THREAD	8

#include <stdio.h>

void	*fonction(void *arg)
{
	t_arg			*a;
	t_mlx			*mlx;
	t_ray			ray;
	int				x;
	int				y;
	double			fov;

	a = (t_arg*)arg;
	mlx = a->mlx;
	fov = mlx->obj.lst_cam->fov * M_PI / 180;
	mlx->obj.intensite_lumiere = 1000000;
	x = 0;
	printf("%f, %f, %f\n", mlx->obj.lst_cam->vec.x, mlx->obj.lst_cam->vec.y, mlx->obj.lst_cam->vec.z);
	while (x < mlx->height)
	{
		y = a->y_min;
		while (y < a->y_max)
		{
			ray.o = mlx->obj.lst_cam->c;
			ray.d = add_vector(init_vector(y - mlx->width / 2, x -
					mlx->height / 2, -(mlx->width) / (2 * tanf(fov / 2))),
					mlx->obj.lst_cam->vec);
			ray.d = normalize(ray.d);
			mlx->image[(mlx->height - x - 1) * mlx->width + y] =
				vector_to_int(getcolor(&ray, &(mlx->obj), 20));
			y++;
		}
		x++;
	}
	return (NULL);
}

int		scenescan(t_mlx *mlx)
{
	pthread_t	thread[NB_THREAD];
	t_arg		arg[NB_THREAD];
	int			num_thread;

	num_thread = -1;
	while (++num_thread < NB_THREAD)
	{
		arg[num_thread].mlx = mlx;
		if (num_thread == 0)
			arg[num_thread].y_min = 0;
		else
			arg[num_thread].y_min = arg[num_thread - 1].y_max;
		arg[num_thread].y_max = mlx->width * (num_thread + 1) / NB_THREAD;
		if (pthread_create(&(thread[num_thread]), NULL, fonction, &(arg[num_thread])))
			return (1);
	}
	num_thread = -1;
	while (++num_thread < NB_THREAD)
		if (pthread_join(thread[num_thread], NULL))
			return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   this_obj_is.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anclarma <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/07/10 10:32:07 by anclarma          #+#    #+#             */
/*   Updated: 2020/07/16 12:19:45 by anclarma         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "struct.h"

int			this_sp_is_mirror(t_obj s, int sphere_id)
{
	t_sphere	*s_ptr;

	s_ptr = s.lst_sphere;
	while (s_ptr)
	{
		if (s_ptr->id == sphere_id)
			return (s_ptr->mirror);
		s_ptr = s_ptr->next;
	}
	return (0);
}

int			this_obj_is_mirror(t_obj s, int obj_id[2])
{
	if (obj_id[0] == 1)
		return (this_sp_is_mirror(s, obj_id[1]));
	return (0);
}

int			this_sp_is_transp(t_obj s, int sphere_id)
{
	t_sphere	*s_ptr;

	s_ptr = s.lst_sphere;
	while (s_ptr)
	{
		if (s_ptr->id == sphere_id)
			return (s_ptr->transp);
		s_ptr = s_ptr->next;
	}
	return (0);
}

int			this_obj_is_transp(t_obj s, int obj_id[2])
{
	if (obj_id[0] == 1)
		return (this_sp_is_transp(s, obj_id[1]));
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vector1.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anclarma <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/07/09 19:09:08 by anclarma          #+#    #+#             */
/*   Updated: 2020/07/09 19:13:29 by anclarma         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "struct.h"
#include <math.h>

t_vector	init_vector(double x, double y, double z)
{
	t_vector	vector;

	vector.x = x;
	vector.y = y;
	vector.z = z;
	return (vector);
}

t_vector	add_vector(const t_vector a, const t_vector b)
{
	return (init_vector(a.x + b.x, a.y + b.y, a.z + b.z));
}

t_vector	sub_vector(const t_vector a, const t_vector b)
{
	return (init_vector(a.x - b.x, a.y - b.y, a.z - b.z));
}

t_vector	mult_vector(double a, const t_vector b)
{
	return (init_vector(a * b.x, a * b.y, a * b.z));
}

t_vector	prod_vector(const t_vector a, const t_vector b)
{
	return (init_vector(a.y * b.z - a.z * b.y,
						b.x * a.z - b.z * a.x,
						a.x * b.y - a.y * b.x));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vector2.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anclarma <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/07/09 19:13:46 by anclarma          #+#    #+#             */
/*   Updated: 2020/07/09 21:01:59 by anclarma         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "struct.h"
#include "vector.h"
#include <math.h>

t_vector	div_vector(const t_vector a, double b)
{
	return (init_vector(a.x / b, a.y / b, a.z / b));
}

double		dot(const t_vector a, const t_vector b)
{
	return (a.x * b.x + a.y * b.y + a.z * b.z);
}

double		norm2(const t_vector vector)
{
	return (vector.x * vector.x + vector.y * vector.y + vector.z * vector.z);
}

t_vector	normalize(t_vector vector)
{
	const double	norm = sqrt(norm2(vector));
	t_vector		vec;

	vec.x = vector.x / norm;
	vec.y = vector.y / norm;
	vec.z = vector.z / norm;
	return (vec);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   vector3.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anclarma <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2020/07/09 19:15:58 by anclarma          #+#    #+#             */
/*   Updated: 2020/07/21 15:10:45 by anclarma         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "struct.h"
#include "extremum.h"
#include <math.h>

t_vector	int_to_vector(int color)
{
	t_vector	new_vec;

	new_vec.x = color % 256;
	color /= 256;
	new_vec.y = color % 256;
	color /= 256;
	new_vec.z = color % 256;
	return (new_vec);
}

int			vector_to_int(t_vector vec)
{
	int			ret;

	ret = (int)max(0.0, min(255.0, pow(vec.x, 1 / 2.2))) +
		(int)max(0.0, min(255.0, pow(vec.y, 1 / 2.2))) * 256 +
		(int)max(0.0, min(255.0, pow(vec.z, 1 / 2.2))) * 256 * 256;
	return (ret);
}

int			vector_to_ints(t_vector vec)
{
	int			ret;

	ret = (int)max(0.0, min(255.0, vec.x)) +
		(int)max(0.0, min(255.0, vec.y)) * 256 +
		(int)max(0.0, min(255.0, vec.z)) * 256 * 256;
	return (ret);
}

//modifie un veteur d'oriantation
// 1	0	0	devant 
// 0	x	x	droite ou gauche (ou haut ou bas)
// -1	0	0	derriere
// 0	x	x	droite ou gauche (ou haut ou bas)
// angle en rad: 0ª = 0, 90ª = ¶/2
// x * cos(-angle) - y * sin(-angle)
// x * sin(-angle) + y * cos(-angle)

t_vector	rot_right(t_vector o, double angle)
{
	t_vector	new_o;

	new_o.x = o.x * cos(-angle) - o.y * sin(-angle);
	new_o.y = o.x * sin(-angle) + o.y * cos(-angle);
	new_o.z = o.z;
	return (new_o);
}

t_vector	rot_left(t_vector o, double angle)
{
	t_vector	new_o;

	new_o.x = o.x * cos(angle) - o.y * sin(angle);
	new_o.y = o.x * sin(angle) + o.y * cos(angle);
	new_o.z = o.z;
	return (new_o);
}
